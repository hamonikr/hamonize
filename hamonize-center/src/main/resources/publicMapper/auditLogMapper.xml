<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.mapper.IAuditLogMapper">

	<select id="pcMntrngListInfo" resultType="com.model.PcMangrVo" parameterType="com.model.PcMangrVo">
		SELECT 
			seq,
			pc_hostname,
			pc_uuid
		FROM tbl_pc_mangr
		<where>
			<if test="org_seq != 1 ">
				org_seq in (
				with recursive search_org(seq,p_seq,org_nm,org_ordr,level,path,cycle) as (
					select a.seq,a.p_seq,a.org_nm,a.org_ordr,0,array[a.seq],false
					from tbl_org a
					where a.seq = #{org_seq}
					union all
					select a.seq,a.p_seq,a.org_nm,a.org_ordr,level+1,path || a.seq,a.seq=any(path)
					from tbl_org a, search_org so 
					where a.p_seq = so.seq and not cycle)
					select seq
					from search_org
				)
		</if>
		</where>

	</select>

	<select id="userLogListInfo" resultType="com.model.AuditLogVo" parameterType="hashmap">
		SELECT  
 	      a.seq, 
		  to_char(a.login_dt,'YYYY-MM-DD HH24:MI:SS') as login_dt, 
		  to_char(a.logout_dt,'YYYY-MM-DD HH24:MI:SS') as logout_dt,
		  EXTRACT(EPOCH FROM age(a.logout_dt, a.login_dt)) * interval '1 sec' as spent_time,
		  (select UPPER(pc_hostname) from tbl_pc_mangr where pc_uuid = a.pc_uuid) as pc_hostname,
		  a.pc_uuid,
		  b.org_seq,
		  ( select org_nm from tbl_org  where seq = b.org_seq and domain=#{auditLogVo.domain})as org_nm,
  		  last_value (a.seq) over(partition by a.pc_uuid order by a.seq ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) as last_seq
		FROM tbl_loginout a left outer join tbl_pc_mangr b on a.pc_uuid = b.pc_uuid
		<where>
			b.domain = #{auditLogVo.domain}
			<if test="auditLogVo.org_seq != null and auditLogVo.org_seq != ''">
				and b.org_seq in (
					with recursive search_org(seq,p_seq,org_nm,org_ordr,level,path,cycle) as (
						select a.seq,a.p_seq,a.org_nm,a.org_ordr,0,array[a.seq],false
						from tbl_org a
						where a.seq = #{auditLogVo.org_seq}
						union all
						select a.seq,a.p_seq,a.org_nm,a.org_ordr,level+1,path || a.seq,a.seq=any(path)
						from tbl_org a, search_org so 
						where a.p_seq = so.seq and not cycle)
						select seq
						from search_org
					)
			</if>
			<if test="auditLogVo.date_fr != null and auditLogVo.date_fr != ''">
				<![CDATA[
				and a.login_dt >= #{auditLogVo.date_fr}::TIMESTAMP
				]]>
			</if>
			<if test="auditLogVo.date_to != null and auditLogVo.date_to != ''">
				<![CDATA[
				and a.login_dt <= #{auditLogVo.date_to}::TIMESTAMP
				]]>
			</if>
			<if test="auditLogVo.txtSearch != ''">
				<if test="auditLogVo.keyWord == 1">
					and (select UPPER(pc_hostname) from tbl_pc_mangr where pc_uuid = a.pc_uuid) like '%' || UPPER(#{auditLogVo.txtSearch}) || '%'
				</if>
			</if>
		</where>
		order by login_dt desc
		OFFSET #{pagingVo.limitStart} LIMIT #{pagingVo.recordSize}
	</select>

	<select id="countUserLogListInfo" parameterType="com.model.AuditLogVo" resultType="Integer">
		
 		SELECT 
		   count(*) as tbl_cnt
		FROM
		  tbl_loginout a
		left outer join tbl_pc_mangr b on  a.pc_uuid = b.pc_uuid

		<where>
			b.domain = #{domain}
			<if test="org_seq != null and org_seq != ''">
				and b.org_seq in (
					with recursive search_org(seq,p_seq,org_nm,org_ordr,level,path,cycle) as (
						select a.seq,a.p_seq,a.org_nm,a.org_ordr,0,array[a.seq],false
						from tbl_org a
						where a.seq = #{org_seq}
						union all
						select a.seq,a.p_seq,a.org_nm,a.org_ordr,level+1,path || a.seq,a.seq=any(path)
						from tbl_org a, search_org so 
						where a.p_seq = so.seq and not cycle)
						select seq
						from search_org
					)
			</if>
			<if test="date_fr != null and date_fr != ''">
				<![CDATA[
				and a.login_dt >= #{date_fr}::TIMESTAMP
				]]>
			</if>
			<if test="date_to != null and date_to != ''">
				<![CDATA[
				and a.login_dt <= #{date_to}::TIMESTAMP
				]]>
			</if>
			<if test="txtSearch != ''">
				<if test="keyWord == 1">
					and (select UPPER(pc_hostname) from tbl_pc_mangr where pc_uuid = a.pc_uuid) like '%' || UPPER(#{txtSearch}) || '%'
				</if>
			</if>
		</where>
	</select>

	<select id="userLogListExcel" resultType="hashmap" parameterType="com.model.AuditLogVo">
		SELECT  
		(ROW_NUMBER() OVER()) AS rownum,
		b.user_sabun,
		case
				when b.rank = '002' then '사원'
				when b.rank = '003' then '대리'
				when b.rank = '004' then '과장' 
				when b.rank = '100' then '관리자' 
				else '부장'
			end as rank,
			b.user_name,
			b.user_id,
		to_char(a.login_dt,'YYYY-MM-DD HH24:MI:SS') as login_dt, 
		to_char(a.logout_dt,'YYYY-MM-DD HH24:MI:SS') as logout_dt, 
		to_char(age(a.logout_dt,a.login_dt),'HH24:MI:SS') as spent_time,
		(select org_nm from tbl_org where seq = (select org_seq from tbl_pc_mangr where pc_uuid = a.pc_uuid))as org_nm,
		(select org_nm from tbl_org where seq=b.org_seq) as join_org_nm
			 FROM tbl_loginout a 
			 left outer join tbl_user b
			 on a.seq = b.seq
		<where>
			<if test="org_seq != null and org_seq != ''">
				and b.org_seq in (
				with recursive search_org(seq,p_seq,org_nm,org_ordr,level,path,cycle) as (
			    select a.seq,a.p_seq,a.org_nm,a.org_ordr,0,array[a.seq],false
			    from tbl_org a
			    where a.seq = #{org_seq}
			    union all
			    select a.seq,a.p_seq,a.org_nm,a.org_ordr,level+1,path || a.seq,a.seq=any(path)
			    from tbl_org a, search_org so 
			    where a.p_seq = so.seq and not cycle)
			    select seq
			    from search_org
				)
			</if>
			<if test="date_fr != null and date_fr != ''">
				<![CDATA[
				and to_char(login_dt,'yyyymmdd') >= #{date_fr}
				]]>
			</if>
			<if test="date_to != null and date_to != ''">
				<![CDATA[
				and to_char(login_dt,'yyyymmdd') <= #{date_to}
				]]>
			</if>
			<if test="keyWord == 1">
				and b.user_name like '%' || #{txtSearch} || '%'
				</if>
			<if test="keyWord == 2">
				and b.user_id like '%' || #{txtSearch} || '%'
				</if>
			<if test="keyWord == 0">
				and (b.user_name like '%' || #{txtSearch} || '%'
				or b.user_id like '%' || #{txtSearch} || '%')
			</if>
		</where>
	</select>


	<select id="iNetLogListInfo" resultType="com.model.AuditLogVo" parameterType="hashmap">
		SELECT
		a.user_id,a.pc_ip,a.cnnc_url,a.pc_uuid,a.hostname,
		case when a.state = 'start' then '브라우저시작'
				when a.state = 'stop' then '브라우저종료'
				when a.state = 'connect' then '인터넷접속'
				when a.state = 'Illegal' then '유해사이트접속' 
				else ''
			end as state, 
		to_char(a.reg_dt,'YYYY-MM-DD HH24:MI:SS.MS') as reg_dt,
		to_char(a.insert_dt,'YYYY-MM-DD HH24:MI:SS') as insert_dt,
		b.user_name,b.org_seq,
			case 
				when b.rank = '002' then '사원'
				when b.rank = '003' then '대리'
				when b.rank = '004' then '과장' 
				when b.rank = '100' then '관리자' 
				else '부장'
			end as rank
			 FROM (select * from tbl_inet_log order by reg_dt desc) a 
			 join tbl_user b
			 on a.user_id = b.user_id
		<where>
			1=1
			<if test="auditLogVo.org_seq != null and auditLogVo.org_seq != ''">
		and b.org_seq in (
				with recursive search_org(seq,p_seq,org_nm,org_ordr,level,path,cycle) as (
    select a.seq,a.p_seq,a.org_nm,a.org_ordr,0,array[a.seq],false
    from tbl_org a
    where a.seq = #{auditLogVo.org_seq}
    union all
    select a.seq,a.p_seq,a.org_nm,a.org_ordr,level+1,path || a.seq,a.seq=any(path)
    from tbl_org a, search_org so 
    where a.p_seq = so.seq and not cycle)
    select seq
    from search_org
				)
		</if>
			<if test="auditLogVo.date_fr != null and auditLogVo.date_fr != ''">
				<![CDATA[
				and to_char(reg_dt,'yyyymmdd') >= #{auditLogVo.date_fr} 
				]]>
			</if>
			<if test="auditLogVo.date_to != null and auditLogVo.date_to != ''">
				<![CDATA[
				and to_char(reg_dt,'yyyymmdd') <= #{auditLogVo.date_to}
				]]>
			</if>
			<if test="auditLogVo.keyWord == 1">
		and b.user_name like '%' || #{auditLogVo.txtSearch} || '%'
		</if>
			<if test="auditLogVo.keyWord == 2">
		and b.user_id like '%' || #{auditLogVo.txtSearch} || '%'
		</if>
			<if test="auditLogVo.keyWord == 0">
		and (b.user_name like '%' || #{auditLogVo.txtSearch} || '%'
		or b.user_id like '%' || #{auditLogVo.txtSearch} || '%')
		</if>
			<if test="auditLogVo.prcssname == 1">
				<if test="auditLogVo.txtSearch0 == 1">
			and a.state = 'connect'
			</if>
				<if test="auditLogVo.txtSearch0 == 2">
			and a.state = 'Illegal'
			</if>
				<if test="auditLogVo.txtSearch1 != ''">
			and b.user_name like '%' || #{auditLogVo.txtSearch1} || '%'
			</if>
				<if test="auditLogVo.txtSearch2 != ''">
			and b.user_id like '%' || #{auditLogVo.txtSearch2} || '%'
			</if>
				<if test="auditLogVo.txtSearch3 != ''">
			and a.hostname = #{auditLogVo.txtSearch3}
			</if>
				<if test="auditLogVo.txtSearch4 != ''">
			and a.cnnc_url like '%' || #{auditLogVo.txtSearch4} || '%'
			</if>
				<if test="auditLogVo.txtSearch5 != 0">
			and b.rank = #{auditLogVo.txtSearch5}
			</if>
			</if>
			and cnnc_url != '-c'
		</where>
		order by a.reg_dt desc
		OFFSET #{pagingVo.limitStart} LIMIT #{pagingVo.recordSize}
	</select>


	<select id="countInetLogListInfo" parameterType="com.model.AuditLogVo" resultType="Integer">
		SELECT 
			count(*)  as tbl_cnt
		FROM tbl_inet_log a 
 		join tbl_user b
 		on a.user_id = b.user_id
		<where>
			1=1
			<if test="org_seq != null and org_seq != ''">
		and b.org_seq in (
				with recursive search_org(seq,p_seq,org_nm,org_ordr,level,path,cycle) as (
    select a.seq,a.p_seq,a.org_nm,a.org_ordr,0,array[a.seq],false
    from tbl_org a
    where a.seq = #{org_seq}
    union all
    select a.seq,a.p_seq,a.org_nm,a.org_ordr,level+1,path || a.seq,a.seq=any(path)
    from tbl_org a, search_org so 
    where a.p_seq = so.seq and not cycle)
    select seq
    from search_org
				)
		</if>
			<if test="date_fr != null and date_fr != ''">
				<![CDATA[
				and to_char(reg_dt,'yyyymmdd') >= #{date_fr} 
				]]>
			</if>
			<if test="date_to != null and date_to != ''">
				<![CDATA[
				and to_char(reg_dt,'yyyymmdd') <= #{date_to}
				]]>
			</if>
			<if test="keyWord == 1">
		and b.user_name like '%' || #{txtSearch} || '%'
		</if>
			<if test="keyWord == 2">
		and b.user_id like '%' || #{txtSearch} || '%'
		</if>
			<if test="keyWord == 0">
		and (b.user_name like '%' || #{txtSearch} || '%'
		or b.user_id like '%' || #{txtSearch} || '%')
		</if>
			<if test="prcssname == 1">
				<if test="txtSearch0 == 1">
			and a.state = 'connect'
			</if>
				<if test="txtSearch0 == 2">
			and a.state = 'Illegal'
			</if>
				<if test="txtSearch1 != ''">
			and b.user_name like '%' || #{txtSearch1} || '%'
			</if>
				<if test="txtSearch2 != ''">
			and b.user_id like '%' || #{txtSearch2} || '%'
			</if>
				<if test="txtSearch3 != ''">
			and a.hostname = #{txtSearch3}
			</if>
				<if test="txtSearch4 != ''">
			and a.cnnc_url like '%' || #{txtSearch4} || '%'
			</if>
				<if test="txtSearch5 != 0">
			and b.rank = #{txtSearch5}
			</if>
			</if>
			and cnnc_url != '-c'
		</where>
	</select>

	<select id="iNetLogListExcel" resultType="hashmap" parameterType="hashmap">
		SELECT
		(ROW_NUMBER() OVER()) AS rownum,
		a.pc_ip,a.cnnc_url,a.pc_uuid,a.hostname,
		case when a.state = 'start' then '브라우저시작'
				when a.state = 'stop' then '브라우저종료'
				when a.state = 'connect' then '인터넷접속'
				when a.state = 'Illegal' then '유해사이트접속' 
				else ''
			end as state, 
		to_char(a.reg_dt,'YYYY-MM-DD HH24:MI:SS.MS') as reg_dt,
		to_char(a.insert_dt,'YYYY-MM-DD HH24:MI:SS') as insert_dt,
		b.user_id,
		b.user_name,
			case 
				when b.rank = '002' then '사원'
				when b.rank = '003' then '대리'
				when b.rank = '004' then '과장'
				when b.rank = '100' then '관리자'
				else '부장'
			end as rank,
			(select org_nm from tbl_org where seq=b.org_seq) as org_nm
			 FROM tbl_inet_log a 
			 join tbl_user b
			 on a.user_id = b.user_id
		<where>
			<if test="org_seq != null and org_seq != ''">
				and b.org_seq in (
				with recursive search_org(seq,p_seq,org_nm,org_ordr,level,path,cycle) as (
    select a.seq,a.p_seq,a.org_nm,a.org_ordr,0,array[a.seq],false
    from tbl_org a
    where a.seq = #{org_seq}
    union all
    select a.seq,a.p_seq,a.org_nm,a.org_ordr,level+1,path || a.seq,a.seq=any(path)
    from tbl_org a, search_org so 
    where a.p_seq = so.seq and not cycle)
    select seq
    from search_org
				)
			</if>
			<if test="date_fr != null and date_fr != ''">
				<![CDATA[
				and to_char(reg_dt,'yyyymmdd') >= #{date_fr} 
				]]>
			</if>
			<if test="date_to != null and date_to != ''">
				<![CDATA[
				and to_char(reg_dt,'yyyymmdd') <= #{date_to}
				]]>
			</if>
			<if test="keyWord == 1">
				and b.user_name like '%' || #{txtSearch} || '%'
				</if>
			<if test="keyWord == 2">
				and b.user_id like '%' || #{txtSearch} || '%'
				</if>
			<if test="keyWord == 0">
				and (b.user_name like '%' || #{txtSearch} || '%'
				or b.user_id like '%' || #{txtSearch} || '%')
			</if>
			<if test="prcssname == 1">
				<if test="txtSearch0 == 1">
				and a.state = 'connect'
				</if>
				<if test="txtSearch0 == 2">
				and a.state = 'Illegal'
				</if>
				<if test="txtSearch1 != ''">
				and b.user_name like '%' || #{txtSearch1} || '%'
				</if>
				<if test="txtSearch2 != ''">
				and b.user_id like '%' || #{txtSearch2} || '%'
				</if>
				<if test="txtSearch3 != ''">
				and a.hostname = #{txtSearch3}
				</if>
				<if test="txtSearch4 != ''">
				and a.cnnc_url like '%' || #{txtSearch4} || '%'
				</if>
				<if test="txtSearch5 != 0">
				and b.rank = #{txtSearch5}
				</if>
			</if>
			and cnnc_url != '-c'
		</where>
	</select>

	<select id="pcChangeLogListInfo" resultType="com.model.AuditLogVo" parameterType="hashmap">
		SELECT
			ta.pc_cpu, 
			ta.pc_memory, 
			ta.pc_disk, 
			ta.pc_macaddress, 
			ta.pc_ip, 
			ta.pc_hostname, 
			ta.pc_disk_id, 
			ta.pc_cpu_id, 
			ta.pc_uuid, 
			to_char(ta.rgstr_date,'YYYY-MM-DD HH24:MI:SS') as rgstr_date
			FROM tbl_pc_hardware_change_log ta
			left outer join tbl_org  tb on ta.org_seq  = tb.seq
		<where>
			tb.domain = #{auditLogVo.domain}
			<if test="auditLogVo.org_seq != null and auditLogVo.org_seq != ''">
			and ta.org_seq in (
				with recursive search_org(domain,seq,p_seq,org_nm,org_ordr,level,path,cycle) as (
				select a.domain,a.seq,a.p_seq,a.org_nm,a.org_ordr,0,array[a.seq],false
				from tbl_org a
				where a.seq = #{auditLogVo.org_seq}
				and a.domain = #{auditLogVo.domain}
				union all
				select b.domain,b.seq,b.p_seq,b.org_nm,b.org_ordr,level+1,path || b.seq,b.seq=any(path)
				from tbl_org b, search_org so 
				where b.p_seq = so.seq and b.domain = so.domain and not cycle)
				select seq
				from search_org
				)
		</if>
			<if test="auditLogVo.date_fr != null and auditLogVo.date_fr != ''">
				<![CDATA[
			and ta.rgstr_date >= #{auditLogVo.date_fr}::TIMESTAMP
			]]>
			</if>
			<if test="auditLogVo.date_to != null and auditLogVo.date_to != ''">
				<![CDATA[
			and ta.rgstr_date <= #{auditLogVo.date_to}::TIMESTAMP
			]]>
			</if>
			<if test="auditLogVo.txtSearch != ''">
				<if test="auditLogVo.keyWord == 1">
			and ta.pc_hostname like '%' || #{auditLogVo.txtSearch} || '%'
			</if>
			</if>
		</where>
		order by ta.rgstr_date desc
		OFFSET #{pagingVo.limitStart} LIMIT #{pagingVo.recordSize}
	</select>


	<select id="countPcChangeLogListInfo" parameterType="com.model.AuditLogVo" resultType="Integer">
		SELECT 
			count(*)  as tbl_cnt
		FROM tbl_pc_hardware_change_log ta
		left outer join tbl_org  tb on ta.org_seq  = tb.seq
		<where>
			tb.domain = #{domain}
			<if test="org_seq != null and org_seq != ''">
			and ta.org_seq in (
				with recursive search_org(domain,seq,p_seq,org_nm,org_ordr,level,path,cycle) as (
				select a.domain,a.seq,a.p_seq,a.org_nm,a.org_ordr,0,array[a.seq],false
				from tbl_org a
				where a.seq = #{org_seq}
				and a.domain = #{domain}
				union all
				select b.domain,b.seq,b.p_seq,b.org_nm,b.org_ordr,level+1,path || b.seq,b.seq=any(path)
				from tbl_org b, search_org so 
				where b.p_seq = so.seq and b.domain = so.domain and not cycle)
				select seq
				from search_org
				)
		</if>
			<if test="date_fr != null and date_fr != ''">
				<![CDATA[
				and ta.rgstr_date >= #{date_fr}::TIMESTAMP
				]]>
			</if>
			<if test="date_to != null and date_to != ''">
				<![CDATA[
				and ta.rgstr_date <= #{date_to}::TIMESTAMP
				]]>
			</if>
			<if test="txtSearch != ''">
				<if test="keyWord == 1">
				and ta.pc_hostname like '%' || #{txtSearch} || '%'
				</if>
			</if>
		</where>
	</select>

	<select id="unAuthLogListInfo" resultType="com.model.AuditLogVo" parameterType="hashmap">
		SELECT
			tu.pc_uuid, 
			tu.vendor, 
			tu.product, 
			tu.info, 
			tpm.pc_hostname, 
			tu.rgstr_date
			from tbl_unauthorized_device_log tu left join tbl_pc_mangr tpm on tpm.pc_uuid = tu.pc_uuid
		<where>
			<if test="auditLogVo.org_seq != null and auditLogVo.org_seq != ''">
		tu.org_seq in (
				with recursive search_org(domain,seq,p_seq,org_nm,org_ordr,level,path,cycle) as (
				select a.domain,a.seq,a.p_seq,a.org_nm,a.org_ordr,0,array[a.seq],false
				from tbl_org a
				where a.seq = #{auditLogVo.org_seq}
				and a.domain = #{auditLogVo.domain}
				union all
				select b.domain,b.seq,b.p_seq,b.org_nm,b.org_ordr,level+1,path || b.seq,b.seq=any(path)
				from tbl_org b, search_org so 
				where b.p_seq = so.seq and b.domain = so.domain and not cycle)
				select seq
				from search_org
				)
		</if>
			<if test="auditLogVo.date_fr != null and auditLogVo.date_fr != ''">
				<![CDATA[
			and tu.rgstr_date >= #{auditLogVo.date_fr}::TIMESTAMP
			]]>
			</if>
			<if test="auditLogVo.date_to != null and auditLogVo.date_to != ''">
				<![CDATA[
			and tu.rgstr_date <= #{auditLogVo.date_to}::TIMESTAMP
			]]>
			</if>
			<if test="auditLogVo.txtSearch != ''">
				<if test="auditLogVo.keyWord == 1">
			and tpm.pc_hostname like '%' || #{auditLogVo.txtSearch} || '%'
			</if>
			</if>
		</where>
		order by tu.rgstr_date desc
		OFFSET #{pagingVo.limitStart} LIMIT #{pagingVo.recordSize}
	</select>


	<select id="countUnAuthLogListInfo" parameterType="com.model.AuditLogVo" resultType="Integer">
		SELECT 
			count(*)  as tbl_cnt
		from tbl_unauthorized_device_log tu left join tbl_pc_mangr tpm on tpm.pc_uuid = tu.pc_uuid
		<where>
			<if test="org_seq != null and org_seq != ''">
			tu.org_seq in (
				with recursive search_org(domain,seq,p_seq,org_nm,org_ordr,level,path,cycle) as (
				select a.domain,a.seq,a.p_seq,a.org_nm,a.org_ordr,0,array[a.seq],false
				from tbl_org a
				where a.seq = #{org_seq}
				and a.domain = #{domain}
				union all
				select b.domain,b.seq,b.p_seq,b.org_nm,b.org_ordr,level+1,path || b.seq,b.seq=any(path)
				from tbl_org b, search_org so 
				where b.p_seq = so.seq and b.domain = so.domain and not cycle)
				select seq
				from search_org
				)
		</if>
			<if test="date_fr != null and date_fr != ''">
				<![CDATA[
			and tu.rgstr_date >= #{date_fr}::TIMESTAMP
			]]>
			</if>
			<if test="date_to != null and date_to != ''">
				<![CDATA[
			and tu.rgstr_date <= #{date_to}::TIMESTAMP
			]]>
			</if>
			<if test="txtSearch != ''">
				<if test="keyWord == 1">
			and tpm.pc_hostname like '%' || #{txtSearch} || '%'
			</if>
			</if>
		</where>
	</select>

	<select id="unAuthLogListExcel" resultType="hashmap" parameterType="hashmap">
		SELECT
		(ROW_NUMBER() OVER()) AS rownum,
		a.pc_uuid,a.vendor,a.product,a.info,
		a.pc_user,a.insert_dt,
			(select org_nm from tbl_org where seq=b.org_seq) as org_nm
			 FROM tbl_unauthorized_device_log a 
			 join tbl_user b
			 on a.pc_user = b.user_id
		<where>
			<if test="org_seq != null and org_seq != ''">
				and b.org_seq in (
				with recursive search_org(seq,p_seq,org_nm,org_ordr,level,path,cycle) as (
    select a.seq,a.p_seq,a.org_nm,a.org_ordr,0,array[a.seq],false
    from tbl_org a
    where a.seq = #{org_seq}
    union all
    select a.seq,a.p_seq,a.org_nm,a.org_ordr,level+1,path || a.seq,a.seq=any(path)
    from tbl_org a, search_org so 
    where a.p_seq = so.seq and not cycle)
    select seq
    from search_org
				)
			</if>
		</where>
	</select>

	<select id="prcssBlockLogListInfo" resultType="com.model.AuditLogVo" parameterType="hashmap">
		
		select 
		  
			( select org_nm from tbl_org where seq = tb.org_seq and  domain=#{auditLogVo.domain}) as org_nm 
			, ta.pc_hostname 
			, ta.progrm_name 
			, ta.pc_ip 
			, ta.rgstr_date
			, tb.org_seq 
			, tb.pc_ip 
			from tbl_progrm_block_log ta, tbl_pc_mangr tb
				
				
		<where>
			ta.pc_uuid  = tb.pc_uuid
			and tb.domain = #{auditLogVo.domain}
			<if test="auditLogVo.org_seq != null and auditLogVo.org_seq != ''">
			and tb.org_seq in (
				with recursive search_org(domain,seq,p_seq,org_nm,org_ordr,level,path,cycle) as (
				select a.domain,a.seq,a.p_seq,a.org_nm,a.org_ordr,0,array[a.seq],false
				from tbl_org a
				where a.seq = #{auditLogVo.org_seq}
				and a.domain = #{auditLogVo.domain}
				union all
				select b.domain,b.seq,b.p_seq,b.org_nm,b.org_ordr,level+1,path || b.seq,b.seq=any(path)
				from tbl_org b, search_org so 
				where b.p_seq = so.seq and b.domain = so.domain and not cycle)
				select seq
				from search_org
						)
			</if>
			<if test="auditLogVo.date_fr != null and auditLogVo.date_fr != ''">
				<![CDATA[
				and ta.rgstr_date >= #{auditLogVo.date_fr}::TIMESTAMP
				]]>
			</if>
			<if test="auditLogVo.date_to != null and auditLogVo.date_to != ''">
				<![CDATA[
				and ta.rgstr_date <= #{auditLogVo.date_to}::TIMESTAMP
				]]>
			</if>
			<if test="auditLogVo.txtSearch != ''">
				<if test="auditLogVo.keyWord == 1">
				and ta.PC_HOSTNAME like '%' || #{auditLogVo.txtSearch} || '%'
				</if>
				<if test="auditLogVo.keyWord == 2">
				and ta.PROGRM_NAME like '%' || #{auditLogVo.txtSearch} || '%'
				</if>
			</if>
		</where>
		order by ta.rgstr_date desc
		OFFSET #{pagingVo.limitStart} LIMIT #{pagingVo.recordSize}
	</select>


	<select id="countPrcssBlockLogListInfo" parameterType="com.model.AuditLogVo" resultType="Integer">
		
		select 
		  count(*)  as tbl_cnt
			from tbl_progrm_block_log ta, tbl_pc_mangr tb

		<where>
			ta.pc_uuid = tb.pc_uuid
			and tb.domain = #{domain}
			<if test="org_seq != null and org_seq != ''">
			and tb.org_seq in (
				with recursive search_org(domain,seq,p_seq,org_nm,org_ordr,level,path,cycle) as (
				select a.domain,a.seq,a.p_seq,a.org_nm,a.org_ordr,0,array[a.seq],false
				from tbl_org a
				where a.seq = #{org_seq}
				and a.domain = #{domain}
				union all
				select b.domain,b.seq,b.p_seq,b.org_nm,b.org_ordr,level+1,path || b.seq,b.seq=any(path)
				from tbl_org b, search_org so 
				where b.p_seq = so.seq and b.domain = so.domain and not cycle)
				select seq
				from search_org
						)
			</if>
			
			<if test="date_fr != null and date_fr != ''">
				<![CDATA[
				and ta.rgstr_date >= #{date_fr}::TIMESTAMP
				]]>
			</if>
			<if test="date_to != null and date_to != ''">
				<![CDATA[
				and ta.rgstr_date <= #{date_to}::TIMESTAMP
				]]>
			</if>
			<if test="txtSearch != ''">
				<if test="keyWord == 1">
				and ta.PC_HOSTNAME like '%' || #{txtSearch} || '%'
				</if>
				<if test="keyWord == 2">
				and ta.PROGRM_NAME like '%' || #{txtSearch} || '%'
				</if>
			</if>
		</where>
	</select>

	<select id="prcssBlockLogListExcel" resultType="hashmap" parameterType="hashmap">
		SELECT
		(ROW_NUMBER() OVER()) AS rownum,
		PC_HOSTNAME,
		(select org_nm from tbl_org where seq = org_seq)as ORG_NM,
		PROGRM_NAME,
		PC_IP,
		RGSTR_DATE,
		USER_ID,
		ORG_SEQ
		FROM tbl_progrm_block_log
		<where>
			<if test="org_seq != null and org_seq != ''">
				and org_seq in (
				with recursive search_org(seq,p_seq,org_nm,org_ordr,level,path,cycle) as (
    select a.seq,a.p_seq,a.org_nm,a.org_ordr,0,array[a.seq],false
    from tbl_org a
    where a.seq = #{org_seq}
    union all
    select a.seq,a.p_seq,a.org_nm,a.org_ordr,level+1,path || a.seq,a.seq=any(path)
    from tbl_org a, search_org so 
    where a.p_seq = so.seq and not cycle)
    select seq
    from search_org
				)
			</if>
			<if test="date_fr != null and date_fr != ''">
				<![CDATA[
				and to_date(insert_dt,'yyyy/mm/dd') >= #{date_fr}::date
				]]>
			</if>
			<if test="date_to != null and date_to != ''">
				<![CDATA[
				and to_date(insert_dt,'yyyy/mm/dd') <= #{date_to}::date
				]]>
			</if>
			<if test="keyWord == 1">
				and (select org_nm from tbl_org where seq = org_seq) = #{txtSearch}
				</if>
			<if test="keyWord == 2">
				and user_id like '%' || #{txtSearch} || '%'
				</if>
			<if test="keyWord == 0">
				and ((select org_nm from tbl_org where seq = org_seq) like '%' || #{txtSearch} || '%'
				or user_id like '%' || #{txtSearch} || '%')
			</if>
		</where>
	</select>

	<!-- 업데이트 정책 배포 -->
	<select id="udptPackageList" resultType="String">
		SELECT PU_NAME FROM tbl_policy_package_list
	</select>


<select id="updtList" resultType="map" parameterType="hashmap">

select GA.*
, GB.*
from (
   select ta.* 
    , tb.deb_apply_name  as debname
    , to_char(tc.rgstr_date, 'YYYY-MM-DD HH24:MI:SS') as rgstr_date
    from (
      select A.ppm_seq, 'INSERT' as gubun 
      , (select job_id from  tbl_updt_applc_history where "domain" = #{domain} and org_seq = #{org_seq}::int order by rgstr_date desc limit 1 OFFSET 0) as job_id
      from 
      (
        select unnest(string_to_array(ppm_seq, ','))::int as ppm_seq from  tbl_updt_applc where domain = #{domain} and org_seq = #{org_seq}::int
        EXCEPT
        select    
          unnest(string_to_array(ta.ppm_seq, ','))::int  as ppm_seq 
        from ( select * from  tbl_updt_applc_history where domain = #{domain} and org_seq = #{org_seq}::int  order by rgstr_date  desc limit 1 OFFSET  1 ) ta 
      ) A
      union all 
      select A.ppm_seq, 'DELETE' as gubun 
      , (select job_id from  tbl_updt_applc_history where "domain" = #{domain} and org_seq = #{org_seq}::int order by rgstr_date desc limit 1 OFFSET 0) as job_id
      from 
      (
        select    
          unnest(string_to_array(ta.ppm_seq, ','))::int  as ppm_seq 
        from ( select * from  tbl_updt_applc_history where domain = #{domain} and org_seq = #{org_seq}::int  order by rgstr_date  desc limit 1 OFFSET  1 ) ta
        EXCEPT
        select unnest(string_to_array(ppm_seq, ','))::int as ppm_seq from  tbl_updt_applc where domain = #{domain} and org_seq = #{org_seq}::int
      ) A 
      union all
      
      select A.ppm_seq , 'M' as gubun 
      , (select job_id from  tbl_updt_applc_history where "domain" = #{domain} and org_seq = #{org_seq}::int order by rgstr_date desc limit 1 OFFSET 1)  as job_id
      from 
      (
        select unnest(string_to_array(ppm_seq, ','))::int as ppm_seq from  tbl_updt_applc where domain = #{domain} and org_seq = #{org_seq}::int
        INTERSECT
        select    
          unnest(string_to_array(ta.ppm_seq, ','))::int  as ppm_seq 
        from ( select * from  tbl_updt_applc_history where domain = #{domain} and org_seq = #{org_seq}::int order by rgstr_date  desc limit 1 OFFSET  1 ) ta 
      ) A
      
    ) ta
    left outer join tbl_policy_package_list tb on ta.ppm_seq = tb.pu_seq 
    left outer join (
      select * from  tbl_updt_applc_history where domain = #{domain} and org_seq = #{org_seq}::int  order by rgstr_date  desc limit 2
    ) tc  on ta.job_id = tc.job_id
) GA
left outer join (
    select 
      sta.* 
    from (
      select
        DISTINCT UNNEST(regexp_split_to_array(ARRAY_TO_STRING(ARRAY_AGG(debname), ',') , ',')) debname
        ,kind, org_seq, rgstr_date, status, pc_uuid, debver
        ,ROW_NUMBER() OVER( PARTITION BY debname order by  rgstr_date desc  ) AS ROW_NUM
      from tbl_act_updt_log
      where 1=1
        and pc_uuid = #{uuid}
        and  rgstr_date > (select rgstr_date from  tbl_updt_applc_history where "domain" = #{domain} and org_seq = #{org_seq}::int order by rgstr_date desc limit 1 OFFSET 0)
        GROUP BY
                debname
                , kind
                , org_seq
                , rgstr_date
                , status
                , pc_uuid
                , debver
      order by ROW_NUM asc  
    ) sta 
    where sta. ROW_NUM = 1
     
  ) GB on GA.debname = GB.debname
order by GA.rgstr_date desc
</select>
	<select id="tmp_updtList" resultType="map" parameterType="hashmap">
		<foreach collection="debList" item="item" index="index">
			(	select
					*
				from
					tbl_act_updt_log tb1
					,tbl_policy_package_list tb2
					where
					tb1.debname = tb2.pu_name
					and tb1.pc_uuid = #{uuid}
					and tb1.debname = #{item}  
				order by tb1.rgstr_date desc limit 1
			)
			<if test="debListCnt > index+1">
				UNION ALL
			</if>
		</foreach>
	</select>

	<!-- 프로그램 차단 정책 배포 -->
	<select id="programPackageList" resultType="String" parameterType="hashmap">
		select
				pu_name as pcm_name
			from
				tbl_policy_package_list
			where
				pu_seq in (
				select
					unnest(string_to_array(ppm_seq, ','))::int
				from
					tbl_updt_applc
				where
					org_seq = (select org_seq from tbl_pc_mangr where pc_uuid = #{pc_uuid}))
	</select>

	<select id="programList" resultType="map" parameterType="hashmap">
		select GA.* 
		, GB.*
		, (
		    select 
		      array_to_string(array(select status || ':' ||  (data -> 'summary_fields' -> 'host' ->> 'description') ||':'||count(status) as status from tbl_ansible_event_job
		    where domain = #{domain} and job_id = GA.job_id
		    group by job_id, data , status), ', ')
		) as run_status
		from (
		   select ta.* 
		    , tb.deb_apply_name  as progrmname
		    , to_char(tc.rgstr_date, 'YYYY-MM-DD HH24:MI:SS.MS')as rgstr_date
		
		    from (
		      select A.ppm_seq, 'INSERT' as gubun 
		      , (select job_id from  tbl_progrm_applc_history where "domain" = #{domain} and org_seq = #{org_seq} order by rgstr_date desc limit 1 OFFSET 0) as job_id
		      from 
		      (
		        select unnest(string_to_array(ppm_seq, ','))::int as ppm_seq from  tbl_progrm_applc where domain = #{domain} and org_seq = #{org_seq}
		        EXCEPT
		        select    
		          unnest(string_to_array(ta.ppm_seq, ','))::int  as ppm_seq 
		        from ( select * from  tbl_progrm_applc_history where domain = #{domain} and org_seq = #{org_seq} order by rgstr_date  desc limit 1 OFFSET  1 ) ta 
		      ) A
		      union all 
		      select A.ppm_seq, 'DELETE' as gubun 
		      , (select job_id from  tbl_progrm_applc_history where "domain" = #{domain} and org_seq = #{org_seq} order by rgstr_date desc limit 1 OFFSET 0) as job_id
		      from 
		      (
		        select    
		          unnest(string_to_array(ta.ppm_seq, ','))::int  as ppm_seq 
		        from ( select * from  tbl_progrm_applc_history where domain = #{domain} and org_seq = #{org_seq}  order by rgstr_date  desc limit 1 OFFSET  1 ) ta
		        EXCEPT
		        select unnest(string_to_array(ppm_seq, ','))::int as ppm_seq from  tbl_progrm_applc where domain = #{domain} and org_seq = #{org_seq}
		      ) A 
		      union all
		      
		      select A.ppm_seq , 'M' as gubun 
		      , (select job_id from  tbl_progrm_applc_history where "domain" = #{domain} and org_seq = #{org_seq} order by rgstr_date desc limit 1 OFFSET 1)  as job_id
		      from 
		      (
		        select unnest(string_to_array(ppm_seq, ','))::int as ppm_seq from  tbl_progrm_applc where domain = #{domain} and org_seq = #{org_seq}
		        INTERSECT
		        select    
		          unnest(string_to_array(ta.ppm_seq, ','))::int  as ppm_seq 
		        from ( select * from  tbl_progrm_applc_history where domain = #{domain} and org_seq = #{org_seq} order by rgstr_date  desc limit 1 OFFSET  1 ) ta 
		      ) A
		      
		    ) ta
		    left outer join tbl_policy_package_list tb on ta.ppm_seq = tb.pu_seq 
		    left outer join (
		      select * from  tbl_progrm_applc_history where domain = #{domain} and org_seq = #{org_seq}  order by rgstr_date  desc limit 2
		    ) tc  on ta.job_id = tc.job_id
		  
		  ) GA
		  
		left outer join (
		  
		          SELECT
		            ROW_NUMBER() OVER( PARTITION BY A.progrmname , A.pc_uuid ORDER BY A.rgstr_date DESC )
		            , A.progrmname
		            , A.kind
		            , A.rgstr_date
		            , A.status
		            , A.pc_uuid
		          FROM
		            (
		              SELECT
		                DISTINCT UNNEST(regexp_split_to_array(ARRAY_TO_STRING(ARRAY_AGG(progrmname), ',') , ',')) progrmname
		                , kind
		                , org_seq
		                , rgstr_date
		                , status
		                , pc_uuid
		              FROM
		                tbl_act_progrm_log
		              WHERE
		                pc_uuid  = #{uuid}
		              and  rgstr_date > (select rgstr_date from  tbl_progrm_applc_history where "domain" = #{domain} and org_seq = #{org_seq} order by rgstr_date desc limit 1 OFFSET 0)
		                GROUP BY
		                progrmname
		                , kind
		                , org_seq
		                , rgstr_date
		                , status
		                , pc_uuid
		            ) A
		          
		  ) GB on GA.progrmname = GB.progrmname
		  
		  where  1=1
		  ORDER BY GA.rgstr_date desc
	</select>
	<select id="tmp_programList" resultType="map" parameterType="hashmap">
		<foreach collection="debList" item="item" index="index">
			(select
						    *
						  from
						    tbl_act_progrm_log tb1
						    ,tbl_policy_progrm_block_list tb2
						  where
						    tb1.progrmname = tb2.pcm_name
						    and tb1.pc_uuid = #{uuid}
						    and upper(tb1.progrmname) =  upper(#{item}) 
						    and tb1.rgstr_date  >= (select rgstr_date from  tbl_progrm_applc_history where domain = #{domain} and org_seq = #{org_seq} order by rgstr_date  desc limit 1 )
						  order by
						    tb1.rgstr_date desc limit 1)
			<if test="debListCnt > index+1">
				            	UNION ALL
				            </if>
		</foreach>
	</select>

	<!-- 방화벽 허용 정책 배포 -->
	<select id="firewallPackageList" resultType="String" parameterType="String">
		SELECT sm_port
		FROM tbl_policy_firewall_list
		where domain = #{domain}
	</select>
	
	<select id="firewallList" resultType="map" parameterType="hashmap">
	
		select GA.*
		, GB.*
		, (
		    select 
		      array_to_string(array(select data -> 'summary_fields' -> 'host' ->> 'description' ||':'||status || ':' || count(status) as status from tbl_ansible_event_job
		    where domain = #{domain} and job_id = GA.job_id
		    group by job_id, data , status), ', ')
		) as run_status
		from (
		   select ta.*
		    , tb.sm_port
		    , to_char(tc.rgstr_date, 'YYYY-MM-DD HH24:MI:SS.MS')as rgstr_date
		    from (
		      select A.ppm_seq, 'INSERT' as gubun 
		      , (select job_id from  tbl_frwl_applc_history where "domain" = #{domain} and org_seq = #{org_seq}::int order by rgstr_date desc limit 1 OFFSET 0) as job_id
		      from 
		      (
		        select unnest(string_to_array(ppm_seq, ','))::int as ppm_seq from  tbl_frwl_applc where domain = #{domain} and org_seq = #{org_seq}::int
		        EXCEPT
		        select    
		          unnest(string_to_array(ta.ppm_seq, ','))::int  as ppm_seq 
		        from ( select * from  tbl_frwl_applc_history where domain = #{domain} and org_seq = #{org_seq}::int  order by rgstr_date  desc limit 1 OFFSET  1 ) ta 
		      ) A
		      union all 
		      select A.ppm_seq, 'DELETE' as gubun 
		      , (select job_id from  tbl_frwl_applc_history where "domain" = #{domain} and org_seq = #{org_seq}::int order by rgstr_date desc limit 1 OFFSET 0) as job_id
		      from 
		      (
		        select    
		          unnest(string_to_array(ta.ppm_seq, ','))::int  as ppm_seq 
		        from ( select * from  tbl_frwl_applc_history where domain = #{domain} and org_seq = #{org_seq}::int order by rgstr_date  desc limit 1 OFFSET  1 ) ta
		        EXCEPT
		        select unnest(string_to_array(ppm_seq, ','))::int as ppm_seq from  tbl_frwl_applc where domain = #{domain} and org_seq = #{org_seq}::int
		      ) A 
		      union all
		      
		      select A.ppm_seq , 'M' as gubun 
		      , (select job_id from  tbl_frwl_applc_history where "domain" = #{domain} and org_seq = #{org_seq}::int order by rgstr_date desc limit 1 OFFSET 1)  as job_id
		      from 
		      (
		        select unnest(string_to_array(ppm_seq, ','))::int as ppm_seq from  tbl_frwl_applc where domain = #{domain} and org_seq = #{org_seq}::int
		        INTERSECT
		        select    
		          unnest(string_to_array(ta.ppm_seq, ','))::int  as ppm_seq 
		        from ( select * from  tbl_frwl_applc_history where domain = #{domain} and org_seq = #{org_seq}::int order by rgstr_date  desc limit 1 OFFSET  1 ) ta 
		      ) A
		      
		    ) ta
		    left outer join tbl_policy_firewall_list tb on ta.ppm_seq = tb.sm_seq 
		    left outer join (
		      select * from  tbl_frwl_applc_history where domain = #{domain} and org_seq = #{org_seq}::int  order by rgstr_date  desc limit 2
		    ) tc  on ta.job_id = tc.job_id
		  
		  ) GA
		  
		
		left outer join (
		   
		          SELECT
		            ROW_NUMBER() OVER( PARTITION BY A.retport , A.pc_uuid ORDER BY A.rgstr_date DESC )
		            , A.retport
		            , A.kind
		            , A.rgstr_date
		            , A.status
		            , A.pc_uuid
		          FROM
		            (
		              SELECT
		                DISTINCT UNNEST(regexp_split_to_array(ARRAY_TO_STRING(ARRAY_AGG(retport), ',') , ',')) retport
		                , kind
		                , org_seq
		                , rgstr_date
		                , status
		                , pc_uuid
		              FROM
		                tbl_act_firewall_log
		              WHERE
		                pc_uuid = #{uuid}
		                 and  rgstr_date > (select rgstr_date from  tbl_frwl_applc_history where "domain" = #{domain} and org_seq = #{org_seq}::int order by rgstr_date desc limit 1 OFFSET 0)
		              GROUP BY
		                retport
		                , kind
		                , org_seq
		                , rgstr_date
		                , status
		                , pc_uuid
		              order by
		                rgstr_date desc
		            ) A
		          WHERE
		            A.retport != ''
		  ) GB on GA.sm_port = GB.retport
		  where  1=1
		  ORDER BY GA.gubun desc
				
				
	</select>

	<!-- 디바이스 허용 정책 배포 -->
	<select id="devicePackageList" parameterType="hashmap" resultType="String">
				SELECT distinct product 
				FROM tbl_act_device_log
				WHERE org_seq in (
					select org_seq 
					from tbl_pc_mangr tpm 
					where pc_uuid = #{uuid}
				)

			 </select>

	<select id="deviceList" parameterType="hashmap" resultType="map">
	
	  select 
    GA.sm_name || '(' ||  GA.sm_device_code || ')' as sm_name
  , GA.ppm_seq
  , GA.gubun
  , GA.job_id
  , GA.sm_device_code
  , to_char(GA.rgstr_date, 'YYYY-MM-DD HH24:MI:SS.MS')as rgstr_date
 , GB.*
, (
    select 
      array_to_string(array(select data -> 'summary_fields' -> 'host' ->> 'description' ||':'||status || ':' || count(status) as status from tbl_ansible_event_job
    where domain = #{domain} and job_id = GA.job_id
    group by job_id, data , status), ', ')
) as run_status
from (


   select ta.*
    , tb.sm_name
    , tb.sm_device_code 
    , tc.rgstr_date
    from (
      select A.ppm_seq, 'INSERT' as gubun 
      , (select job_id from  tbl_device_applc_history where "domain" = #{domain} and org_seq = #{org_seq}::int order by rgstr_date desc limit 1 OFFSET 0) as job_id
      from 
      (
        select unnest(string_to_array(ppm_seq, ','))::int as ppm_seq from  tbl_device_applc where domain = #{domain} and org_seq = #{org_seq}::int
        EXCEPT
        select    
          unnest(string_to_array(ta.ppm_seq, ','))::int  as ppm_seq 
        from ( select * from  tbl_device_applc_history where domain = #{domain} and org_seq = #{org_seq}::int order by rgstr_date  desc limit 1 OFFSET  1 ) ta 
      ) A
      union all 
      select A.ppm_seq, 'DELETE' as gubun 
      , (select job_id from  tbl_device_applc_history where "domain" = #{domain} and org_seq = #{org_seq}::int order by rgstr_date desc limit 1 OFFSET 0) as job_id
      from 
      (
        select    
          unnest(string_to_array(ta.ppm_seq, ','))::int  as ppm_seq 
        from ( select * from  tbl_device_applc_history where domain = #{domain} and org_seq = #{org_seq}::int  order by rgstr_date  desc limit 1 OFFSET  1 ) ta
        EXCEPT
        select unnest(string_to_array(ppm_seq, ','))::int as ppm_seq from  tbl_device_applc where domain = #{domain} and org_seq = #{org_seq}::int
      ) A 
      union all
      
      select A.ppm_seq , 'M' as gubun 
      , (select job_id from  tbl_device_applc_history where "domain" = #{domain} and org_seq = #{org_seq}::int order by rgstr_date desc limit 1 OFFSET 1)  as job_id
      from 
      (
        select unnest(string_to_array(ppm_seq, ','))::int as ppm_seq from  tbl_device_applc where domain = #{domain} and org_seq = #{org_seq}::int
        INTERSECT
        select    
          unnest(string_to_array(ta.ppm_seq, ','))::int  as ppm_seq 
        from ( select * from  tbl_device_applc_history where domain = #{domain} and org_seq = #{org_seq}::int order by rgstr_date  desc limit 1 OFFSET  1 ) ta 
      ) A
      
    ) ta
    left outer join tbl_policy_device_list tb on ta.ppm_seq = tb.sm_seq 
    left outer join (
      select * from  tbl_device_applc_history where domain = #{domain} and org_seq = #{org_seq}::int  order by rgstr_date  desc limit 2
    ) tc  on ta.job_id = tc.job_id
  
  ) GA
  
  

left outer join (
  
          SELECT
            ROW_NUMBER() OVER( PARTITION BY A.product , A.pc_uuid ORDER BY A.rgstr_date DESC )
            , A.product
            , A.rgstr_date
            , A.status
            , A.vendorcode
            , A.productcode
          FROM
            (
              SELECT
                 DISTINCT UNNEST(regexp_split_to_array(ARRAY_TO_STRING(ARRAY_AGG(product), ',') , ',')) product
                , pc_uuid
                , pc_hostname
                , status
                , rgstr_date
                , vendorcode
                , productcode
              FROM
                tbl_act_device_log
              WHERE
                 pc_uuid  = #{uuid}
                 and  rgstr_date > (select rgstr_date from  tbl_device_applc_history where "domain" = #{domain} and org_seq = #{org_seq}::int order by rgstr_date desc limit 1 OFFSET 0)
              GROUP BY
                pc_uuid
                , pc_hostname
                , status
                , product
                , rgstr_date
                , vendorcode
                , productcode
              order by
                rgstr_date desc
            ) A
          WHERE
            A.product != ''
  ) GB on GA.sm_name = GB.product
  where  1=1
  ORDER BY GA.gubun desc
  
	</select>
	<select id="tmp_deviceList" parameterType="hashmap" resultType="map">
		<foreach collection="debList" item="item" index="index">
			(select t.*
							from(
							select row_number () over (order by rgstr_date desc) as row,*
							from tbl_act_device_log
							where pc_uuid =  #{uuid} and product = #{item}
							) t
							limit 1
						)
			<if test="debListCnt > index+1">
				            	UNION ALL
				        </if>
		</foreach>
	</select>

	<!-- 유해사이트 정책 배포 -->
	<select id="nxssList" resultType="map" parameterType="hashmap">
				    (select
						    *
						  from
						    tbl_act_nxss_log tb1
						  where
						     tb1.uuid = #{uuid}
						  order by
						    tb1.ins_date desc limit 2)
			 </select>

</mapper>
